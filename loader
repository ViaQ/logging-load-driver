#!/usr/bin/env python
#
# ViaQ logging load generator
#
# Copyright 2018 Red Hat, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from __future__ import print_function

import sys
import time
import uuid
import random
import string
import logging
import logging.handlers
import argparse


DEFAULT_STDDEV = 32


def msgsizgen_fixed(mean, stddev = None):
    '''Generate a series of "fixed" sizes, always yielding the given
       "mean" as the value.

       The stddev value is always ignored.
    '''
    while True:
        yield mean


def msgsizgen_gaussian(mean, stddev = DEFAULT_STDDEV):
    '''Generate a series of random numbers with a Guassian distribution,
       where the mean and standard deviation are given arguments.

       The mean is a required parameter, while the stddev will default to
       32.

       The generator will yield numbers continuously.
    '''
    randomizer = random.Random()
    while True:
        yield int(round(randomizer.gauss(mean, stddev)))


dist_methods = { 'fixed': msgsizgen_fixed, 'gaussian': msgsizgen_gaussian, 'normal': msgsizgen_gaussian }


def load(invocid, size, output_method, report_method, dist='gaussian', stddev=DEFAULT_STDDEV, report_interval=(10000,1), seq_width=10, chars=string.ascii_lowercase + string.digits, msgpersec=0):
    '''Emit a formatted payload of random bytes, using a Gaussian
       distribution using a given size as the mean.  The payload
       is emitted using the output_method function, while statistics
       about the output rate are reported through the report_method.

       The reports are generated once every 10,000 payloads, no
       more than once a second by default. Both parameters can be
       changed by the caller.

       The generated sequence number defaults to a width of 10.

       The invocation ID, invocid, is required from the caller to
       facilitate finding the output emitted by this instance.
    '''
    msgsizgen = dist_methods[dist]
    sep = ' - '
    sep_len = len(sep)
    seq = 0
    start = past = time.time()
    msgs = 0
    prefix = "loader seq - %s - " % invocid
    prefix_len = len(prefix)
    sub_len = (prefix_len + seq_width + sep_len)
    if msgpersec > 0:
        msgperiod = (1/msgpersec, time.time() + 1/msgpersec, msgpersec)
    else:
        msgperiod = None
    try:
        for asize in msgsizgen(size, stddev):
            asize -= sub_len
            asize = 1 if asize <= 0 else asize
            msg = ''.join(random.choice(chars) for x in range(asize))
            seq += 1
            msgs += 1
            output_method("%s%0*d%s%s" % (prefix, seq_width, seq, sep, msg))
            if seq % report_interval[0] == 0:
                now = time.time()
                diff = now - past
                if (diff > report_interval[1]):
                    msg_rate = msgs / diff
                    total_msg_rate = seq / (now - start)
                    if msgperiod:
                        if msg_rate < (msgperiod[2] - 0.50):
                            notice = " (too slow, %.4f)" % msgperiod[2]
                        elif msg_rate > (msgperiod[2] + 0.50):
                            notice = " (too fast, %.4f)" % msgperiod[2]
                        else:
                            notice = ""
                    else:
                        notice = ""
                    report_method("loader stat: %0*d %10.3f%s %10.3f" % (seq_width, seq, msg_rate, notice, total_msg_rate))
                    past = now
                    msgs = 0
            if msgperiod is not None:
                now = time.time()
                if now >= msgperiod[1]:
                    # We have exited our rate-limit window, calculate next
                    # window and continue
                    msgperiod = (msgperiod[0], msgperiod[1] + msgperiod[0], msgperiod[2])
                # Wait until our window is up
                sleep_window = msgperiod[1] - now
                while now < msgperiod[1]:
                    time.sleep(sleep_window)
                    now = time.time()
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    log = logging.getLogger(__name__)
    log.setLevel(logging.INFO)
    formatter = logging.Formatter('%(module)s.%(funcName)s: %(message)s')
    try:
        handler = logging.handlers.SysLogHandler(address = '/dev/log')
        handler.setFormatter(formatter)
    except Exception:
        consoleHandler = logging.StreamHandler()
        consoleHandler.setFormatter(formatter)
        log.addHandler(consoleHandler)
    else:
        log.addHandler(handler)

    parser = argparse.ArgumentParser(description='Message payload generator.')
    parser.add_argument('payload_size', metavar='SIZE', type=int, nargs='?',
            default=1024,
			help='an integer specifying the mean size of the payload using a Gaussian distribution')
    parser.add_argument('--distribution', metavar='DIST', dest='payload_dist', action='store',
            default='gaussian', choices=dist_methods,
            help='the size distribution to use, e.g. "gaussian" (default), "normal" (alias for gaussian), or "fixed"')
    parser.add_argument('--invocid', metavar='INVOCID', dest='invocid', action='store',
            default=uuid.uuid4().hex,
			help='the unique invocation ID string to use (defaults to 32 char generated one)')
    parser.add_argument('--stddev', metavar='STDDEV', dest='stddev', type=float,
            default=DEFAULT_STDDEV,
            help='the standard deviation to use with a random distribution (defaults to 32)')
    parser.add_argument('--output', metavar='METHOD', dest='output', action='store',
            default='stdout',
            help='where to emit the output, one of: "stdout", "stderr", "syslog", "<file name>" (defaults to "stdout")')
    parser.add_argument('--report', metavar='METHOD', dest='report', action='store',
            default='stderr',
            help='where to emit the report output, one of: "stdout", "stderr", "syslog", "<file name>" (defaults to "stderr")')
    parser.add_argument('--msgpersec', metavar='MSGPERSEC', dest='msgpersec', type=float,
            default=0,
            help='the # of logs per second (floating point) to emit (defaults to 0, unlimited)')
    parser.add_argument('--report-interval', metavar='INTERVAL', dest='reportint', type=int,
            default=10000,
            help='the # of messages between reports (defaults to 10,000)')
    args = parser.parse_args()

    # Determine the output method to emit logs
    if args.output == 'syslog':
        output_method = log.debug
    else:
        if args.output in ('stderr', 'stdout'):
            ofp = getattr(sys, args.output)
        else:
            # Assume the parameter is a file name
            ofp = open(args.output, "w")
        def output_closure(payload):
            ofp.write(payload + '\n')
        output_method = output_closure

    # Determine the report method to use
    if args.report == 'syslog':
        report_method = log.info
    else:
        if args.report in ('stderr', 'stdout'):
            rfp = getattr(sys, args.report)
        else:
            # Assume the parameter is a file name
            rfp = open(args.report, "w")
        def report_closure(payload):
            rfp.write(payload + '\n')
        report_method = report_closure

    load(args.invocid, args.payload_size, output_method, report_method,
            dist=args.payload_dist, stddev=args.stddev, msgpersec=args.msgpersec,
            report_interval=(args.reportint, 1))
